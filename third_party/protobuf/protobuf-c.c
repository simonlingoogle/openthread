/*
 *    Copyright 2016 Nest Labs Inc. All Rights Reserved.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/*
 * Copyright (c) 2008-2015, Dave Benson and the protobuf-c authors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*! \file
 * Support library for `protoc-c` generated code.
 *
 * This file implements the public API used by the code generated
 * by `protoc-c`.
 *
 * \authors Dave Benson and the protobuf-c authors
 *
 * \copyright 2008-2014. Licensed under the terms of the [BSD-2-Clause] license.
 */

/**
 * \todo 64-BIT OPTIMIZATION: certain implementations use 32-bit math
 * even on 64-bit platforms (uint64_size, uint64_pack, parse_uint64).
 *
 * \todo Use size_t consistently.
 */

#include <stdlib.h>     /* for malloc, free */
#include <string.h>     /* for strcmp, strlen, memcpy, memmove, memset */

#include "protobuf-c.h"

#define TRUE                            1
#define FALSE                           0

#define PROTOBUF_C__ASSERT_NOT_REACHED() assert(0)

/**
 * \defgroup internal Internal functions and macros
 *
 * These are not exported by the library but are useful to developers working
 * on `libprotobuf-c` itself.
 */

/**
 * \defgroup macros Utility macros for manipulating structures
 *
 * Macros and constants used to manipulate the base "classes" generated by
 * `protobuf-c`. They also define limits and check correctness.
 *
 * \ingroup internal
 * @{
 */

/** The maximum length of a 64-bit integer in varint encoding. */
#define MAX_UINT64_ENCODED_SIZE         10

#ifndef PROTOBUF_C_UNPACK_ERROR
# define PROTOBUF_C_UNPACK_ERROR(...)
#endif

/**
 * Internal `ProtobufCMessage` manipulation macro.
 *
 * Base macro for manipulating a `ProtobufCMessage`. Used by STRUCT_MEMBER() and
 * STRUCT_MEMBER_PTR().
 */
#define STRUCT_MEMBER_P(struct_p, struct_offset) \
  ((void *) ((uint8_t *) (struct_p) + (struct_offset)))

/**
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset.
 * Cast it to the passed type.
 */
#define STRUCT_MEMBER(member_type, struct_p, struct_offset) \
  (*(member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))

/**
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset. Cast
 * it to a pointer to the passed type.
 */
#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset) \
  ((member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))

/* Assertions for magic numbers. */

#define ASSERT_IS_MESSAGE_DESCRIPTOR(desc)                      \
  assert((desc)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC)

#define ASSERT_IS_MESSAGE(message) \
  ASSERT_IS_MESSAGE_DESCRIPTOR((message)->descriptor)

/**@}*/

/**
 * \defgroup packedsz protobuf_c_message_get_packed_size() implementation
 *
 * Routines mainly used by protobuf_c_message_get_packed_size().
 *
 * \ingroup internal
 * @{
 */

/**
 * Return the number of bytes required to store a variable-length unsigned
 * 32-bit integer in base-128 varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
uint32_size(uint32_t v)
{
  if (v < (1 << 7)) {
    return 1;
  } else if (v < (1 << 14)) {
    return 2;
  } else if (v < (1 << 21)) {
    return 3;
  } else if (v < (1 << 28)) {
    return 4;
  } else {
    return 5;
  }
}

/**
 * Return the ZigZag-encoded 32-bit unsigned integer form of a 32-bit signed
 * integer.
 *
 * \param v
 *      Value to encode.
 * \return
 *      ZigZag encoded integer.
 */
static inline uint32_t
zigzag32(int32_t v)
{
  if (v < 0)
    return ((uint32_t) (-v)) * 2 - 1;
  else
    return v * 2;
}

/**
 * Return the ZigZag-encoded 64-bit unsigned integer form of a 64-bit signed
 * integer.
 *
 * \param v
 *      Value to encode.
 * \return
 *      ZigZag encoded integer.
 */
static inline uint64_t
zigzag64(int64_t v)
{
  if (v < 0)
    return ((uint64_t) (-v)) * 2 - 1;
  else
    return v * 2;
}

/**
 * \defgroup pack protobuf_c_message_pack() implementation
 *
 * Routines mainly used by protobuf_c_message_pack().
 *
 * \ingroup internal
 * @{
 */

/**
 * Pack an unsigned 32-bit integer in base-128 varint encoding and return the
 * number of bytes written, which must be 5 or less.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
uint32_pack(uint32_t value, uint8_t *out)
{
  unsigned rv = 0;

  if (value >= 0x80) {
    out[rv++] = value | 0x80;
    value >>= 7;
    if (value >= 0x80) {
      out[rv++] = value | 0x80;
      value >>= 7;
      if (value >= 0x80) {
        out[rv++] = value | 0x80;
        value >>= 7;
        if (value >= 0x80) {
          out[rv++] = value | 0x80;
          value >>= 7;
        }
      }
    }
  }
  /* assert: value<128 */
  out[rv++] = value;
  return rv;
}

/**
 * Pack a signed 32-bit integer and return the number of bytes written.
 * Negative numbers are encoded as two's complement 64-bit integers.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
int32_pack(int32_t value, uint8_t *out)
{
  if (value < 0) {
    out[0] = value | 0x80;
    out[1] = (value >> 7) | 0x80;
    out[2] = (value >> 14) | 0x80;
    out[3] = (value >> 21) | 0x80;
    out[4] = (value >> 28) | 0x80;
    out[5] = out[6] = out[7] = out[8] = 0xff;
    out[9] = 0x01;
    return 10;
  } else {
    return uint32_pack(value, out);
  }
}

/**
 * Pack a signed 32-bit integer using ZigZag encoding and return the number of
 * bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint32_pack(int32_t value, uint8_t *out)
{
  return uint32_pack(zigzag32(value), out);
}

/**
 * Pack a 64-bit unsigned integer using base-128 varint encoding and return the
 * number of bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
uint64_pack(uint64_t value, uint8_t *out)
{
  uint32_t hi = (uint32_t) (value >> 32);
  uint32_t lo = (uint32_t) value;
  unsigned rv;

  if (hi == 0)
    return uint32_pack((uint32_t) lo, out);
  out[0] = (lo) | 0x80;
  out[1] = (lo >> 7) | 0x80;
  out[2] = (lo >> 14) | 0x80;
  out[3] = (lo >> 21) | 0x80;
  if (hi < 8) {
    out[4] = (hi << 4) | (lo >> 28);
    return 5;
  } else {
    out[4] = ((hi & 7) << 4) | (lo >> 28) | 0x80;
    hi >>= 3;
  }
  rv = 5;
  while (hi >= 128) {
    out[rv++] = hi | 0x80;
    hi >>= 7;
  }
  out[rv++] = hi;
  return rv;
}

/**
 * Pack a 64-bit signed integer in ZigZag encoding and return the number of
 * bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint64_pack(int64_t value, uint8_t *out)
{
  return uint64_pack(zigzag64(value), out);
}

/**
 * Pack a 32-bit quantity in little-endian byte order. Used for protobuf wire
 * types fixed32, sfixed32, float. Similar to "htole32".
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed32_pack(uint32_t value, void *out)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, &value, 4);
#else
  uint8_t *buf = out;

  buf[0] = value;
  buf[1] = value >> 8;
  buf[2] = value >> 16;
  buf[3] = value >> 24;
#endif
  return 4;
}

/**
 * Pack a 64-bit quantity in little-endian byte order. Used for protobuf wire
 * types fixed64, sfixed64, double. Similar to "htole64".
 *
 * \todo The big-endian impl is really only good for 32-bit machines, a 64-bit
 * version would be appreciated, plus a way to decide to use 64-bit math where
 * convenient.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed64_pack(uint64_t value, void *out)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, &value, 8);
  #else
  fixed32_pack(value, out);
  fixed32_pack(value >> 32, ((char *) out) + 4);
  #endif
  return 8;
}

/**
 * Pack a boolean value as an integer and return the number of bytes written.
 *
 * \todo Perhaps on some platforms *out = !!value would be a better impl, b/c
 * that is idiomatic C++ in some STL implementations.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
boolean_pack(protobuf_c_boolean value, uint8_t *out)
{
  *out = value ? TRUE : FALSE;
  return 1;
}

/**
 * Pack a NUL-terminated C string and return the number of bytes written. The
 * output includes a length delimiter.
 *
 * The NULL pointer is treated as an empty string. This isn't really necessary,
 * but it allows people to leave required strings blank. (See Issue #13 in the
 * bug tracker for a little more explanation).
 *
 * \param str
 *      String to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
string_pack(const char *str, uint8_t *out)
{
  if (str == NULL) {
    out[0] = 0;
    return 1;
  } else {
    size_t len = strlen(str);
    size_t rv = uint32_pack(len, out);
    memcpy(out + rv, str, len);
    return rv + len;
  }
}

/**
 * Pack a ProtobufCBinaryData and return the number of bytes written. The output
 * includes a length delimiter.
 *
 * \param bd
 *      ProtobufCBinaryData to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
binary_data_pack(const ProtobufCBinaryData *bd, uint8_t *out)
{
  size_t len = bd->len;
  size_t rv = uint32_pack(len, out);
  memcpy(out + rv, &bd->data, len);
  return rv + len;
}

/**
 * Pack a ProtobufCMessage and return the number of bytes written. The output
 * includes a length delimiter.
 *
 * \param message
 *      ProtobufCMessage object to pack.
 * \param[out] out
 *      Packed message.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
prefixed_message_pack(const ProtobufCMessage *message, uint8_t *out)
{
  if (message == NULL) {
    out[0] = 0;
    return 1;
  } else {
    size_t rv = protobuf_c_message_pack(message, out + 1);
    uint32_t rv_packed_size = uint32_size(rv);
    if (rv_packed_size != 1)
      memmove(out + rv_packed_size, out + 1, rv);
    return uint32_pack(rv, out) + rv;
  }
}

/**
 * Pack a field tag.
 *
 * Wire-type will be added in required_field_pack().
 *
 * \todo Just call uint64_pack on 64-bit platforms.
 *
 * \param id
 *      Tag value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
tag_pack(uint32_t id, uint8_t *out)
{
  if (id < (1 << (32 - 3)))
    return uint32_pack(id << 3, out);
  else
    return uint64_pack(((uint64_t) id) << 3, out);
}

/**
 * Pack a required field and return the number of bytes written.
 *
 * \param field
 *      Field descriptor.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
required_field_pack(const ProtobufCFieldDescriptor *field,
                    const void *member, uint8_t *out)
{
  size_t rv = tag_pack(field->id, out);

  switch (field->type) {
    case PROTOBUF_C_TYPE_SINT32:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + sint32_pack(*(const int32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_INT32:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + int32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_ENUM:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + uint32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SINT64:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + sint64_pack(*(const int64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + uint64_pack(*(const uint64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      out[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;
      return rv + fixed32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      out[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;
      return rv + fixed64_pack(*(const uint64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_BOOL:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + boolean_pack(*(const protobuf_c_boolean *) member, out + rv);
    case PROTOBUF_C_TYPE_STRING:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      return rv + string_pack((const char *) member, out + rv);
    case PROTOBUF_C_TYPE_BYTES:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      return rv + binary_data_pack((const ProtobufCBinaryData *) member, out + rv);
    case PROTOBUF_C_TYPE_MESSAGE:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      return rv + prefixed_message_pack((const ProtobufCMessage *) member, out + rv);
  }
  PROTOBUF_C__ASSERT_NOT_REACHED();
  return 0;
}

/**
 * Pack a oneof field and return the number of bytes written. Only packs the
 * field that is selected by the case enum.
 *
 * \param field
 *      Field descriptor.
 * \param oneof_case
 *      A pointer to the case enum that selects the field in the oneof.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
oneof_field_pack(const ProtobufCFieldDescriptor *field,
                 const uint32_t *oneof_case,
                 const void *member, uint8_t *out)
{
  if (*oneof_case != field->id)
    return 0;
  return required_field_pack(field, member, out);
}

/**
 * Pack an optional field and return the number of bytes written.
 *
 * \param field
 *      Field descriptor.
 * \param has
 *      Whether the field is set.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
optional_field_pack(const ProtobufCFieldDescriptor *field,
                    const protobuf_c_boolean *has,
                    const void *member, uint8_t *out)
{
  if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
      field->type == PROTOBUF_C_TYPE_STRING)
  {
    const void *ptr = *(const void * const *) member;
    if (ptr == NULL || ptr == field->default_value)
      return 0;
  } else {
    if (!*has)
      return 0;
  }
  return required_field_pack(field, member, out);
}

/**
 * Given a field type, return the in-memory size.
 *
 * \todo Implement as a table lookup.
 *
 * \param type
 *      Field type.
 * \return
 *      Size of the field.
 */
static inline size_t
sizeof_elt_in_repeated_array(const ProtobufCFieldDescriptor *field)
{
  switch (field->type) {
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
    case PROTOBUF_C_TYPE_ENUM:
      return 4;
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      return 8;
    case PROTOBUF_C_TYPE_BOOL:
      return sizeof(protobuf_c_boolean);
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
    case PROTOBUF_C_TYPE_BYTES:
      return field->elt_size;
  }
  PROTOBUF_C__ASSERT_NOT_REACHED();
  return 0;
}

/**
 * Pack an array of 32-bit quantities.
 *
 * \param[out] out
 *      Destination.
 * \param[in] in
 *      Source.
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_32(void *out, const void *in, const unsigned n)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, in, n * 4);
#else
  unsigned i;
  const uint32_t *ini = in;
  for (i = 0; i < n; i++)
    fixed32_pack(ini[i], (uint32_t *) out + i);
#endif
}

/**
 * Pack an array of 64-bit quantities.
 *
 * \param[out] out
 *      Destination.
 * \param[in] in
 *      Source.
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_64(void *out, const void *in, const unsigned n)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, in, n * 8);
#else
  unsigned i;
  const uint64_t *ini = in;
  for (i = 0; i < n; i++)
    fixed64_pack(ini[i], (uint64_t *) out + i);
#endif
}

/**
 * Get the minimum number of bytes required to pack a field value of a
 * particular type.
 *
 * \param type
 *      Field type.
 * \return
 *      Number of bytes.
 */
static unsigned
get_type_min_size(ProtobufCType type)
{
  if (type == PROTOBUF_C_TYPE_SFIXED32 ||
                  type == PROTOBUF_C_TYPE_FIXED32 ||
      type == PROTOBUF_C_TYPE_FLOAT)
  {
    return 4;
  }
  if (type == PROTOBUF_C_TYPE_SFIXED64 ||
                  type == PROTOBUF_C_TYPE_FIXED64 ||
      type == PROTOBUF_C_TYPE_DOUBLE)
  {
    return 8;
  }
  return 1;
}

/**
 * Packs the elements of a repeated field and returns the serialised field and
 * its length.
 *
 * \param field
 *      Field descriptor.
 * \param count
 *      Number of elements in the repeated field array.
 * \param member
 *      Pointer to the elements for this repeated field.
 * \param[out] out
 *      Serialised representation of the repeated field.
 * \return
 *      Number of bytes serialised to `out`.
 */
static size_t
repeated_field_pack(const ProtobufCFieldDescriptor *field,
                    size_t count, const void *member, uint8_t *out)
{
  const void *array = (const void *) member;
  unsigned i;

  if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
    unsigned header_len;
    unsigned len_start;
    unsigned min_length;
    unsigned payload_len;
    unsigned length_size_min;
    unsigned actual_length_size;
    uint8_t *payload_at;

    if (count == 0)
      return 0;
    header_len = tag_pack(field->id, out);
    out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
    len_start = header_len;
    min_length = get_type_min_size(field->type) * count;
    length_size_min = uint32_size(min_length);
    header_len += length_size_min;
    payload_at = out + header_len;

    switch (field->type) {
      case PROTOBUF_C_TYPE_SFIXED32:
      case PROTOBUF_C_TYPE_FIXED32:
      case PROTOBUF_C_TYPE_FLOAT:
        copy_to_little_endian_32(payload_at, array, count);
        payload_at += count * 4;
        break;
      case PROTOBUF_C_TYPE_SFIXED64:
      case PROTOBUF_C_TYPE_FIXED64:
      case PROTOBUF_C_TYPE_DOUBLE:
        copy_to_little_endian_64(payload_at, array, count);
        payload_at += count * 8;
        break;
      case PROTOBUF_C_TYPE_INT32: {
        const int32_t *arr = (const int32_t *) array;
        for (i = 0; i < count; i++)
          payload_at += int32_pack(arr[i], payload_at);
        break;
      }
      case PROTOBUF_C_TYPE_SINT32: {
        const int32_t *arr = (const int32_t *) array;
        for (i = 0; i < count; i++)
          payload_at += sint32_pack(arr[i], payload_at);
        break;
      }
      case PROTOBUF_C_TYPE_SINT64: {
        const int64_t *arr = (const int64_t *) array;
        for (i = 0; i < count; i++)
          payload_at += sint64_pack(arr[i], payload_at);
        break;
      }
      case PROTOBUF_C_TYPE_ENUM:
      case PROTOBUF_C_TYPE_UINT32: {
        const uint32_t *arr = (const uint32_t *) array;
        for (i = 0; i < count; i++)
          payload_at += uint32_pack(arr[i], payload_at);
        break;
      }
      case PROTOBUF_C_TYPE_INT64:
      case PROTOBUF_C_TYPE_UINT64: {
        const uint64_t *arr = (const uint64_t *) array;
        for (i = 0; i < count; i++)
          payload_at += uint64_pack(arr[i], payload_at);
        break;
      }
      case PROTOBUF_C_TYPE_BOOL: {
        const protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;
        for (i = 0; i < count; i++)
          payload_at += boolean_pack(arr[i], payload_at);
        break;
      }
      default:
        PROTOBUF_C__ASSERT_NOT_REACHED();
    }

    payload_len = payload_at - (out + header_len);
    actual_length_size = uint32_size(payload_len);
    if (length_size_min != actual_length_size) {
      assert(actual_length_size == length_size_min + 1);
      memmove(out + header_len + 1, out + header_len,
              payload_len);
      header_len++;
    }
    uint32_pack(payload_len, out + len_start);
    return header_len + payload_len;
  } else {
    /* not "packed" cased */
    /* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */
    size_t rv = 0;
    unsigned siz = sizeof_elt_in_repeated_array(field);

    for (i = 0; i < count; i++) {
      rv += required_field_pack(field, array, out + rv);
      array = (char *)array + siz;
    }
    return rv;
  }
}

/**@}*/

size_t
protobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)
{
  unsigned i;
  size_t rv = 0;

  ASSERT_IS_MESSAGE(message);
  for (i = 0; i < message->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor *field =
        message->descriptor->fields + i;
    const void *member = ((const char *) message) + field->offset;

    /*
     * It doesn't hurt to compute qmember (a pointer to the
     * quantifier field of the structure), but the pointer is only
     * valid if the field is:
     *  - a repeated field, or
     *  - a field that is part of a oneof
     *  - an optional field that isn't a pointer type
     * (Meaning: not a message or a string).
     */
    const void *qmember =
        ((const char *) message) + field->quantifier_offset;

    if (field->label == PROTOBUF_C_LABEL_REQUIRED) {
      rv += required_field_pack(field, member, out + rv);
    } else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {
      if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))
        rv += oneof_field_pack (field, qmember, member, out + rv);
      else
        rv += optional_field_pack(field, qmember, member, out + rv);
    } else {
      rv += repeated_field_pack(field, *(const size_t *) qmember,
                                member, out + rv);
    }
  }

  return rv;
}

/**
 * \defgroup unpack unpacking implementation
 *
 * Routines mainly used by the unpacking functions.
 *
 * \ingroup internal
 * @{
 */

static inline int
int_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)
{
  unsigned n;
  unsigned start;

  if (n_ranges == 0)
    return -1;
  start = 0;
  n = n_ranges;
  while (n > 1) {
    unsigned mid = start + n / 2;

    if (value < ranges[mid].start_value) {
      n = mid - start;
    } else if (value >= ranges[mid].start_value +
               (int) (ranges[mid + 1].orig_index -
                      ranges[mid].orig_index))
    {
      unsigned new_start = mid + 1;
      n = start + n - new_start;
      start = new_start;
    } else
      return (value - ranges[mid].start_value) +
          ranges[mid].orig_index;
  }
  if (n > 0) {
    unsigned start_orig_index = ranges[start].orig_index;
                    unsigned range_size =
                        ranges[start + 1].orig_index - start_orig_index;

                    if (ranges[start].start_value <= value &&
                        value < (int) (ranges[start].start_value + range_size))
                    {
                      return (value - ranges[start].start_value) +
                          start_orig_index;
                    }
  }
  return -1;
}

static size_t
parse_tag_and_wiretype(size_t len,
                       const uint8_t *data,
                       uint32_t *tag_out,
                       ProtobufCWireType *wiretype_out)
{
  unsigned max_rv = len > 5 ? 5 : len;
  uint32_t tag = (data[0] & 0x7f) >> 3;
  unsigned shift = 4;
  unsigned rv;

  *wiretype_out = data[0] & 7;
  if ((data[0] & 0x80) == 0) {
    *tag_out = tag;
    return 1;
  }
  for (rv = 1; rv < max_rv; rv++) {
    if (data[rv] & 0x80) {
      tag |= (data[rv] & 0x7f) << shift;
      shift += 7;
    } else {
      tag |= data[rv] << shift;
      *tag_out = tag;
      return rv + 1;
    }
  }
  return 0; /* error: bad header */
}

typedef struct _ScannedMember ScannedMember;
/** Field as it's being read. */
struct _ScannedMember {
  uint32_t tag;              /**< Field tag. */
  uint8_t wire_type;         /**< Field type. */
  uint8_t length_prefix_len; /**< Prefix length. */
  const ProtobufCFieldDescriptor *field; /**< Field descriptor. */
  size_t len;                /**< Field length. */
  const uint8_t *data;       /**< Pointer to field data. */
};

static inline uint32_t
scan_length_prefixed_data(size_t len, const uint8_t *data,
                          size_t *prefix_len_out)
{
  unsigned hdr_max = len < 5 ? len : 5;
  unsigned hdr_len;
  uint32_t val = 0;
  unsigned i;
  unsigned shift = 0;

  for (i = 0; i < hdr_max; i++) {
    val |= (data[i] & 0x7f) << shift;
    shift += 7;
    if ((data[i] & 0x80) == 0)
      break;
  }
  if (i == hdr_max) {
    PROTOBUF_C_UNPACK_ERROR("error parsing length for length-prefixed data");
    return 0;
  }
  hdr_len = i + 1;
  *prefix_len_out = hdr_len;
  if (hdr_len + val > len) {
    PROTOBUF_C_UNPACK_ERROR("data too short after length-prefix of %u", val);
    return 0;
  }
  return hdr_len + val;
}

/**@}*/

static inline uint32_t
parse_uint32(unsigned len, const uint8_t *data)
{
  uint32_t rv = data[0] & 0x7f;
  if (len > 1) {
    rv |= ((uint32_t) (data[1] & 0x7f) << 7);
    if (len > 2) {
      rv |= ((uint32_t) (data[2] & 0x7f) << 14);
      if (len > 3) {
        rv |= ((uint32_t) (data[3] & 0x7f) << 21);
        if (len > 4)
          rv |= ((uint32_t) (data[4]) << 28);
      }
    }
  }
  return rv;
}

static inline uint32_t
parse_int32(unsigned len, const uint8_t *data)
{
  return parse_uint32(len, data);
}

static inline int32_t
unzigzag32(uint32_t v)
{
  if (v & 1)
    return -(v >> 1) - 1;
  else
    return v >> 1;
}

static inline uint32_t
parse_fixed_uint32(const uint8_t *data)
{
#if !defined(WORDS_BIGENDIAN)
  uint32_t t;
  memcpy(&t, data, 4);
  return t;
  #else
          return data[0] |
              ((uint32_t) (data[1]) << 8) |
              ((uint32_t) (data[2]) << 16) |
              ((uint32_t) (data[3]) << 24);
          #endif
}

static uint64_t
parse_uint64(unsigned len, const uint8_t *data)
{
  unsigned shift, i;
  uint64_t rv;

  if (len < 5)
    return parse_uint32(len, data);
  rv = ((uint64_t) (data[0] & 0x7f)) |
      ((uint64_t) (data[1] & 0x7f) << 7) |
      ((uint64_t) (data[2] & 0x7f) << 14) |
      ((uint64_t) (data[3] & 0x7f) << 21);
  shift = 28;
  for (i = 4; i < len; i++) {
    rv |= (((uint64_t) (data[i] & 0x7f)) << shift);
    shift += 7;
  }
  return rv;
}

static inline int64_t
unzigzag64(uint64_t v)
{
  if (v & 1)
    return -(v >> 1) - 1;
  else
    return v >> 1;
}

static inline uint64_t
parse_fixed_uint64(const uint8_t *data)
{
#if !defined(WORDS_BIGENDIAN)
  uint64_t t;
  memcpy(&t, data, 8);
  return t;
  #else
  return (uint64_t) parse_fixed_uint32(data) |
      (((uint64_t) parse_fixed_uint32(data + 4)) << 32);
  #endif
}

static protobuf_c_boolean
parse_boolean(unsigned len, const uint8_t *data)
{
  unsigned i;
  for (i = 0; i < len; i++)
    if (data[i] & 0x7f)
      return TRUE;
  return FALSE;
}

static protobuf_c_boolean
parse_required_member(ScannedMember *scanned_member,
                      void *member)
{
  unsigned len = scanned_member->len;
  const uint8_t *data = scanned_member->data;
  ProtobufCWireType wire_type = scanned_member->wire_type;

  switch (scanned_member->field->type) {
    case PROTOBUF_C_TYPE_INT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(uint32_t *) member = parse_int32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_UINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(uint32_t *) member = parse_uint32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_SINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(int32_t *) member = unzigzag32(parse_uint32(len, data));
      return TRUE;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT)
        return FALSE;
      *(uint32_t *) member = parse_fixed_uint32(data);
      return TRUE;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(uint64_t *) member = parse_uint64(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_SINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(int64_t *) member = unzigzag64(parse_uint64(len, data));
      return TRUE;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT)
        return FALSE;
      *(uint64_t *) member = parse_fixed_uint64(data);
      return TRUE;
    case PROTOBUF_C_TYPE_BOOL:
      *(protobuf_c_boolean *) member = parse_boolean(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_ENUM:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
        return FALSE;
      *(uint32_t *) member = parse_uint32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_STRING: {
      char *pstr = member;
      unsigned pref_len = scanned_member->length_prefix_len;

      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
        return FALSE;
      if ((len - pref_len) > scanned_member->field->max_length)
        return FALSE;

      memcpy(pstr, data + pref_len, len - pref_len);
      pstr[len - pref_len] = 0;
      return TRUE;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      ProtobufCBinaryData *bd = member;
      unsigned pref_len = scanned_member->length_prefix_len;

      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
        return FALSE;
      if ((len - pref_len) > scanned_member->field->max_length)
        return FALSE;

      memcpy(&bd->data, data + pref_len, len - pref_len);
      bd->len = len - pref_len;
      return TRUE;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      ProtobufCMessage *subm;
      unsigned pref_len = scanned_member->length_prefix_len;

      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
        return FALSE;

      subm = protobuf_c_message_unpack(scanned_member->field->descriptor,
                                       len - pref_len,
                                       data + pref_len,
                                       (ProtobufCMessage *)member);

      if (subm == NULL)
        return FALSE;
      return TRUE;
    }
  }
  return FALSE;
}

static protobuf_c_boolean
parse_oneof_member (ScannedMember *scanned_member,
                    void *member,
                    ProtobufCMessage *message)
{
  uint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,
                                           scanned_member->field->quantifier_offset);

  if (!parse_required_member (scanned_member, member))
    return FALSE;

  *oneof_case = scanned_member->tag;
  return TRUE;
}

static protobuf_c_boolean
parse_optional_member(ScannedMember *scanned_member,
                      void *member,
                      ProtobufCMessage *message)
{
  if (!parse_required_member(scanned_member, member))
    return FALSE;
  if (scanned_member->field->quantifier_offset != 0)
    STRUCT_MEMBER(protobuf_c_boolean,
                  message,
                  scanned_member->field->quantifier_offset) = TRUE;
  return TRUE;
}

static protobuf_c_boolean
parse_repeated_member(ScannedMember *scanned_member,
                      void *member,
                      ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor *field = scanned_member->field;
  size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);
  size_t siz = sizeof_elt_in_repeated_array(field);
  char *array = (char *) member;

  if (*p_n >= field->max_repeat ||
      !parse_required_member(scanned_member, array + siz * (*p_n)))
    return FALSE;
  *p_n += 1;
  return TRUE;
}

static unsigned
scan_varint(unsigned len, const uint8_t *data)
{
  unsigned i;
  if (len > 10)
    len = 10;
  for (i = 0; i < len; i++)
    if ((data[i] & 0x80) == 0)
      break;
  if (i == len)
    return 0;
  return i + 1;
}

static protobuf_c_boolean
parse_packed_repeated_member(ScannedMember *scanned_member,
                             void *member,
                             ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor *field = scanned_member->field;
  size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);
  size_t siz = sizeof_elt_in_repeated_array(field);
  void *array = (char *) member + siz * (*p_n);
  const uint8_t *at = scanned_member->data + scanned_member->length_prefix_len;
  size_t rem = scanned_member->len - scanned_member->length_prefix_len;
  size_t count = 0;
  unsigned i;

  if (*p_n >= field->max_repeat)
    return FALSE;

  switch (field->type) {
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      count = (scanned_member->len - scanned_member->length_prefix_len) / 4;
#if !defined(WORDS_BIGENDIAN)
      goto no_unpacking_needed;
      #else
      for (i = 0; i < count; i++) {
        ((uint32_t *) array)[i] = parse_fixed_uint32(at);
        at += 4;
      }
      break;
      #endif
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      count = (scanned_member->len - scanned_member->length_prefix_len) / 8;
#if !defined(WORDS_BIGENDIAN)
      goto no_unpacking_needed;
      #else
      for (i = 0; i < count; i++) {
        ((uint64_t *) array)[i] = parse_fixed_uint64(at);
        at += 8;
      }
      break;
      #endif
    case PROTOBUF_C_TYPE_INT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated int32 value");
          return FALSE;
        }
        ((int32_t *) array)[count++] = parse_int32(s, at);
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_SINT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated sint32 value");
          return FALSE;
        }
        ((int32_t *) array)[count++] = unzigzag32(parse_uint32(s, at));
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_ENUM:
    case PROTOBUF_C_TYPE_UINT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated enum or uint32 value");
          return FALSE;
        }
        ((uint32_t *) array)[count++] = parse_uint32(s, at);
        at += s;
        rem -= s;
      }
      break;

    case PROTOBUF_C_TYPE_SINT64:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated sint64 value");
          return FALSE;
        }
        ((int64_t *) array)[count++] = unzigzag64(parse_uint64(s, at));
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated int64/uint64 value");
          return FALSE;
        }
        ((int64_t *) array)[count++] = parse_uint64(s, at);
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_BOOL:
      count = rem;
      for (i = 0; i < count; i++) {
        if (at[i] > 1) {
          PROTOBUF_C_UNPACK_ERROR("bad packed-repeated boolean value");
          return FALSE;
        }
        ((protobuf_c_boolean *) array)[i] = at[i];
      }
      break;
    default:
      PROTOBUF_C__ASSERT_NOT_REACHED();
  }
  *p_n += count;
  return TRUE;

#if !defined(WORDS_BIGENDIAN)
no_unpacking_needed:
  memcpy(array, at, count * siz);
  *p_n += count;
  return TRUE;
  #endif
}

static protobuf_c_boolean
is_packable_type(ProtobufCType type)
{
  return
      type != PROTOBUF_C_TYPE_STRING &&
      type != PROTOBUF_C_TYPE_BYTES &&
      type != PROTOBUF_C_TYPE_MESSAGE;
}

static protobuf_c_boolean
parse_member(ScannedMember *scanned_member,
             ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor *field = scanned_member->field;
  void *member;

  if (field == NULL)
    return TRUE;

  member = (char *) message + field->offset;
  switch (field->label) {
    case PROTOBUF_C_LABEL_REQUIRED:
      return parse_required_member(scanned_member, member);
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
        return parse_oneof_member(scanned_member, member,
                                  message);
      } else {
        return parse_optional_member(scanned_member, member,
                                     message);
      }
    case PROTOBUF_C_LABEL_REPEATED:
      if (scanned_member->wire_type ==
                              PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
          (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
           is_packable_type(field->type)))
      {
        return parse_packed_repeated_member(scanned_member,
                                            member, message);
      } else {
        return parse_repeated_member(scanned_member,
                                     member, message);
      }
  }
  PROTOBUF_C__ASSERT_NOT_REACHED();
  return 0;
}

#define REQUIRED_FIELD_BITMAP_SET(index)        \
  (required_fields_bitmap[(index)/8] |= (1<<((index)%8)))

#define REQUIRED_FIELD_BITMAP_IS_SET(index)     \
  (required_fields_bitmap[(index)/8] & (1<<((index)%8)))

ProtobufCMessage *
protobuf_c_message_unpack(const ProtobufCMessageDescriptor *desc,
                          size_t len, const uint8_t *data,
                          ProtobufCMessage *message)
{
  ProtobufCMessage *rv = message;
  size_t rem = len;
  const uint8_t *at = data;
  const ProtobufCFieldDescriptor *last_field = desc->fields + 0;

  unsigned last_field_index = 0;
  unsigned required_fields_bitmap_len = 4;
  unsigned char required_fields_bitmap[required_fields_bitmap_len];

  memset(required_fields_bitmap, 0, required_fields_bitmap_len);

  /*
   * Generated code always defines "message_init". However, we provide a
   * fallback for (1) users of old protobuf-c generated-code that do not
   * provide the function, and (2) descriptors constructed from some other
   * source (most likely, direct construction from the .proto file).
   */
  if (desc->message_init != NULL)
    protobuf_c_message_init(desc, rv);
  else
    return FALSE;

  while (rem > 0) {
    uint32_t tag;
    ProtobufCWireType wire_type;
    size_t used = parse_tag_and_wiretype(rem, at, &tag, &wire_type);
    const ProtobufCFieldDescriptor *field;
    ScannedMember tmp;
    
    if (used == 0 || used > rem) {
      PROTOBUF_C_UNPACK_ERROR("error parsing tag/wiretype at offset %u",
                              (unsigned) (at - data));
      goto error_cleanup_during_scan;
    }
    /*
     * \todo Consider optimizing for field[1].id == tag, if field[1]
     * exists!
     */
    if (last_field == NULL || last_field->id != tag) {
      /* lookup field */
      int field_index =
          int_range_lookup(desc->n_field_ranges,
                           desc->field_ranges,
                           tag);
      if (field_index < 0) {
        field = NULL;
      } else {
        field = desc->fields + field_index;
        last_field = field;
        last_field_index = field_index;
      }
    } else {
      field = last_field;
    }

    if (field != NULL && field->label == PROTOBUF_C_LABEL_REQUIRED)
      REQUIRED_FIELD_BITMAP_SET(last_field_index);

    at += used;
    rem -= used;
    tmp.tag = tag;
    tmp.wire_type = wire_type;
    tmp.field = field;
    tmp.data = at;
    tmp.length_prefix_len = 0;

    switch (wire_type) {
      case PROTOBUF_C_WIRE_TYPE_VARINT: {
        unsigned max_len = rem < 10 ? rem : 10;
        unsigned i;

        for (i = 0; i < max_len; i++)
          if ((at[i] & 0x80) == 0)
            break;
        if (i == max_len) {
          PROTOBUF_C_UNPACK_ERROR("unterminated varint at offset %u",
                                  (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = i + 1;
        break;
      }
      case PROTOBUF_C_WIRE_TYPE_64BIT:
        if (rem < 8) {
          PROTOBUF_C_UNPACK_ERROR("too short after 64bit wiretype at offset %u",
                                  (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = 8;
        break;
      case PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED: {
        size_t pref_len;

        tmp.len = scan_length_prefixed_data(rem, at, &pref_len);
        if (tmp.len == 0) {
          /* NOTE: scan_length_prefixed_data calls UNPACK_ERROR */
          goto error_cleanup_during_scan;
        }
        tmp.length_prefix_len = pref_len;
        break;
      }
      case PROTOBUF_C_WIRE_TYPE_32BIT:
        if (rem < 4) {
          PROTOBUF_C_UNPACK_ERROR("too short after 32bit wiretype at offset %u",
                                  (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = 4;
        break;
      default:
        PROTOBUF_C_UNPACK_ERROR("unsupported tag %u at offset %u",
                                wire_type, (unsigned) (at - data));
        goto error_cleanup_during_scan;
    }

    if (field != NULL) {
      if (!parse_member(&tmp, message)) {
        PROTOBUF_C_UNPACK_ERROR("error parsing member at offset %u",
                                (unsigned) (at - data));
        goto error_cleanup;
      }
    }

    at += tmp.len;
    rem -= tmp.len;
  }

  return rv;

error_cleanup:
error_cleanup_during_scan:
  return NULL;
}

void
protobuf_c_message_init(const ProtobufCMessageDescriptor * descriptor,
                        void *message)
{
  descriptor->message_init((ProtobufCMessage *) (message));
}
